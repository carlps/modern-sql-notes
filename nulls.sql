/*
https://modern-sql.com/concept/null
These are my notes and examples from the above post
2019-07-28
The SQL was all run on PostgreSQL 11.4
*/

-- Setup
DROP TABLE IF EXISTS null_fun;

CREATE TABLE null_fun (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    fname VARCHAR(255),
    lname VARCHAR(255),
    age INTEGER
    );

INSERT INTO null_fun VALUES
  (DEFAULT, 'carlos', 'torres', 28),
  (DEFAULT, 'Duane', 'Lo Mein', 42),
  (DEFAULT, 'homer', NULL, NULL),
  (DEFAULT, NULL, NULL, 228),
  (DEFAULT, 'mario', 'mario', NULL),
  (DEFAULT, 'luigi', 'mario', NULL)
;
  
SELECT * FROM null_fun;
/* example data
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 1    | carlos  | torres  | 28     |
| 2    | Duane   | Lo Mein | 42     |
| 3    | homer   | <null>  | <null> |
| 4    | <null>  | <null>  | 228    |
| 5    | mario   | mario   | <null> |
| 6    | luigi   | mario   | <null> |
+------+---------+---------+--------+
*/

-------------------------------
-- 1 Comparisons Involving NULL
-------------------------------

-- Comparing to NULL is neither tru nor false, but instead the 3rd logical value of SQL: unknown
-- WHERE treats unknown like false

SELECT *
FROM null_fun
WHERE age = NULL;
/* 0 rows
+------+---------+---------+-------+
| id   | fname   | lname   | age   |
|------+---------+---------+-------|
+------+---------+---------+-------+
*/

-- when testing for NULL, must use IS [NOT] NULL

SELECT *
FROM null_fun
WHERE age IS NULL;
/* 3 rows
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 3    | homer   | <null>  | <null> |
| 5    | mario   | mario   | <null> |
| 6    | luigi   | mario   | <null> |
+------+---------+---------+--------+
*/

SELECT *
FROM null_fun
WHERE age IS NOT NULL;
/* 3 rows
+------+---------+---------+-------+
| id   | fname   | lname   | age   |
|------+---------+---------+-------|
| 1    | carlos  | torres  | 28    |
| 2    | Duane   | Lo Mein | 42    |
| 4    | <null>  | <null>  | 228   |
+------+---------+---------+-------+
*/

-- SQL uses 2 differenct concepts to tell if two values are the "same"
-- equals and DISTINCT
-- equals treats comparisons to NULL as indeterminate (that's why col = NULL returns unknown)
-- DISTINCT treats NULL like any other value 
-- ie 2 NULL values are not distinct from each other, they are indistinguishable
-- whereas a NULL and a not NULL are distinct values (not the same)
-- we can use IS DISTINCT FROM to make DISTINCT comparisons

SELECT *
FROM null_fun
WHERE fname = lname;
/* 1 row
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 5    | mario   | mario   | <null> |
+------+---------+---------+--------+
*/

SELECT *
FROM null_fun
WHERE fname IS NOT DISTINCT FROM lname;
/* 2 rows
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 4    | <null>  | <null>  | 228    |
| 5    | mario   | mario   | <null> |
+------+---------+---------+--------+
*/

SELECT *
FROM null_fun
WHERE fname != lname;
/* 3 rows
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 1    | carlos  | torres  | 28     |
| 2    | Duane   | Lo Mein | 42     |
| 6    | luigi   | mario   | <null> |
+------+---------+---------+--------+
*/

SELECT *
FROM null_fun
WHERE fname IS DISTINCT FROM lname;
/* 4 rows (note id 3 not in previous)
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 1    | carlos  | torres  | 28     |
| 2    | Duane   | Lo Mein | 42     |
| 3    | homer   | <null>  | <null> |
| 6    | luigi   | mario   | <null> |
+------+---------+---------+--------+
*/

-------------------------------
-- 2 Mappring to and from NULL
-------------------------------

-- Sometimes you need to convert a value to/from NULL
-- There are 2 shortcuts from CASE for the most common operations

-- COALESCE will turn a NULL into another value

SELECT
  id,
  fname,
  COALESCE(fname, 'No name given') AS "first name"
FROM null_fun;
/*
+------+---------+---------------+
| id   | fname   | first name    |
|------+---------+---------------|
| 1    | carlos  | carlos        |
| 2    | Duane   | Duane         |
| 3    | homer   | homer         |
| 4    | <null>  | No name given |
| 5    | mario   | mario         |
| 6    | luigi   | luigi         |
+------+---------+---------------+
*/

-- COALESCE will take an arbitrary number of args and return the first NOT NULL argument
-- if all are NULL, it will return NULL

SELECT
  id,
  fname,
  lname,
  COALESCE(lname, fname, 'no name given') AS "name with fallback",
  COALESCE(lname, fname) AS "name without fallback"
FROM null_fun;
/*
+------+---------+---------+----------------------+-------------------------+
| id   | fname   | lname   | name with fallback   | name without fallback   |
|------+---------+---------+----------------------+-------------------------|
| 1    | carlos  | torres  | torres               | torres                  |
| 2    | Duane   | Lo Mein | Lo Mein              | Lo Mein                 |
| 3    | homer   | <null>  | homer                | homer                   |
| 4    | <null>  | <null>  | no name given        | <null>                  |
| 5    | mario   | mario   | mario                | mario                   |
| 6    | luigi   | mario   | mario                | mario                   |
+------+---------+---------+----------------------+-------------------------+
*/

-- NULLIF maps one particualr value to NULL
-- If arg1 equals arg2, the result is NULL
-- If arg1 != arg2, the result is arg1

SELECT
  id,
  age,
  NULLIF(age, 228) AS "cleaned_age"
FROM null_fun;
/*
+------+--------+---------------+
| id   | age    | cleaned_age   |
|------+--------+---------------|
| 1    | 28     | 28            |
| 2    | 42     | 42            |
| 3    | <null> | <null>        |
| 4    | 228    | <null>        |
| 5    | <null> | <null>        |
| 6    | <null> | <null>        |
+------+--------+---------------+
*/

-- the general CASE can be used for other cases
-- such as mapping multiple values to NULL
-- or using other comparisons

SELECT
  id,
  fname,
  lname,
  age,
  CASE WHEN fname IN ('carlos', 'mario')
       THEN NULL
       ELSE fname
  END AS "lame_names",
  CASE WHEN age > 100
       THEN NULL
       ELSE age
  END AS "cleaned_age"
FROM null_fun;
/*
+------+---------+---------+--------+--------------+---------------+
| id   | fname   | lname   | age    | lame_names   | cleaned_age   |
|------+---------+---------+--------+--------------+---------------|
| 1    | carlos  | torres  | 28     | <null>       | 28            |
| 2    | Duane   | Lo Mein | 42     | Duane        | 42            |
| 3    | homer   | <null>  | <null> | homer        | <null>        |
| 4    | <null>  | <null>  | 228    | <null>       | <null>        |
| 5    | mario   | mario   | <null> | <null>       | <null>        |
| 6    | luigi   | mario   | <null> | luigi        | <null>        |
+------+---------+---------+--------+--------------+---------------+
*/

----------------------------------------------------
-- Null Propagates Through Expressions
----------------------------------------------------

-- expressions and functions that process a NULL value generally return the NULL value
-- Aggregate functions and two-logical operations are noteworthy exceptions

-- the results of the following are all NULL
SELECT 1 + NULL;
/*
+------------+
| ?column?   |
|------------|
| <null>     |
+------------+
*/

SELECT 'foo ' || NULL || 'bar';
/*
+------------+
| ?column?   |
|------------|
| <null>     |
+------------+
*/

SELECT SUBSTRING('foo bar' FROM 4 FOR NULL);
/*
+-------------+
| substring   |
|-------------|
| <null>      |
+-------------+
*/
-- NOTE that oracle treats empty string and null as interchangeable
-- so the || example would be 'foo bar' on an Oracle db


-- NOTE that non-standard functions may or may not follow the idea that NULL propogates
-- for example the CONCAT() function
-- most DBs support it. DB2, MySQL and MariaDB will return NULL
-- H2, Oracle, PostgreSQL, and SQL Server treat NULL as an empty string

-- postgres example
SELECT CONCAT('foo ', NULL, 'bar');
/*
+----------+
| concat   |
|----------|
| foo bar  |
+----------+
*/


-- Logical expressions (AND, OR, NOT) treat NULL as the 3rd truth value UNKNOWN
-- NULL will propagate through logical expressions only if the result becomes
-- undecidable due to a NULL operand
-- So there are  cases in which result will not be NULL
-- NULL AND False => False because (* AND False) == False
-- TRUE OR NULL => True because (TRUE OR *) == True

SELECT
  True OR NULL AS "True or NULL",
  NULL AND False AS "NULL and False",
  True AND NULL AS "True and NULL",
  NULL OR False AS "NULL or False",
  NOT NULL AS "NOT NULL"
;
/*
+----------------+------------------+-----------------+-----------------+------------+
| True or NULL   | NULL and False   | True and NULL   | NULL or False   | NOT NULL   |
|----------------+------------------+-----------------+-----------------+------------|
| True           | False            | <null>          | <null>          | <null>     |
+----------------+------------------+-----------------+-----------------+------------+
*/

----------------------------------------------------
-- Null in Aggregate Functions (count, sum, â€¦)
----------------------------------------------------

-- Aggregates generally remove NULL values from their input before performing the aggregation
-- This means the result of an aggregate function doesn't necessarily become NULL if the input contains NULL values
-- This behavior is most often used to implement pivot queries
-- The result of an aggregate function is only NULL if it operates on effectively empty set
-- This can happen if all rows are removed (only NULLs or just a filter)
-- Or an explicit or implicit GROUP BY is applied to an empty set

SELECT
  SUM(age) as "combined age"
FROM null_fun;
/*
+----------------+
| combined age   |
|----------------|
| 298            |
+----------------+
*/

SELECT
  SUM(age) as "combined age"
FROM null_fun
WHERE age < 0;
/*
+----------------+
| combined age   |
|----------------|
| <null>         |
+----------------+
*/
WITH no_age AS (
  SELECT *
  FROM null_fun
  WHERE age IS NULL
)
SELECT
  SUM(age) AS "combined age"
FROM no_age
GROUP BY age;
/*
+----------------+
| combined age   |
|----------------|
| <null>         |
+----------------+
*/

-- COUNT and REGR_COUNT never return NULL
-- The will return numerical 0 for an effectivel empty set

SELECT COUNT(*)
FROM null_fun
WHERE age < 0;
/*
+---------+
| count   |
|---------|
| 0       |
+---------+
*/

SELECT REGR_COUNT(NULL, NULL);
/*
+--------------+
| regr_count   |
|--------------|
| 0            |
+--------------+
*/

-- Most aggregate functions taht return structured data do not remove NULL values
-- ex ARRAY_AGG, JSON_OBJECTAGG, XMLAGG
-- JSON_ARRAYAGG default to ABSENT ON NULL (as opposed to json_objectagg)
---- standard but not followed by most implementations

SELECT
  ARRAY_AGG(age)
FROM null_fun;
/*
+---------------------------------+
| array_agg                       |
|---------------------------------|
| [28, 42, None, 228, None, None] |
+---------------------------------+
*/
SELECT
  JSON_OBJECT_AGG('age', age),
FROM null_fun;
/*
+-----------------------------------------------------------------------------------+
| json_object_agg                                                                   |
|-----------------------------------------------------------------------------------|
| { "age" : 28, "age" : 42, "age" : null, "age" : 228, "age" : null, "age" : null } |
+-----------------------------------------------------------------------------------+
*/

SELECT
  JSON_AGG(age)
FROM null_fun;
/*
+---------------------------------+
| json_agg                        |
|---------------------------------|
| [28, 42, null, 228, null, null] |
+---------------------------------+
*/

----------------------------------------------------
-- Null in Distinct, Group by, Partition by, Union, etc.
----------------------------------------------------

-- grouping operations use DISTINCT COMPARISONS to check if 2 values belong to the same group
-- that means all NULL values are put into a single group

SELECT
  age,
  ARRAY_AGG(fname) AS "Names by age"
FROM null_fun
GROUP BY age
ORDER BY age;
/*
+--------+-----------------------------+
| age    | Names by age                |
|--------+-----------------------------|
| 28     | ['carlos']                  |
| 42     | ['Duane']                   |
| 228    | [None]                      |
| <null> | ['homer', 'mario', 'luigi'] |
+--------+-----------------------------+
*/

-- This also affects operations that are specified in terms of grouping
-- DISTINCT (in SELECT or aggregates), PARTITION BY, UNION (w/o ALL), etc

SELECT
  DISTINCT age
FROM null_fun;
/*
+--------+
| age    |
|--------|
| 228    |
| <null> |
| 42     |
| 28     |
+--------+
*/

SELECT NULL
UNION
SELECT NULL
UNION 
SELECT 'asdf';
/*
+------------+
| ?column?   |
|------------|
| <null>     |
| asdf       |
+------------+
*/

SELECT
  age,
  fname,
  AVG(age)
OVER (partition BY age)
FROM null_fun;
/*
+--------+---------+----------------------+
| age    | fname   | avg                  |
|--------+---------+----------------------|
| 28     | carlos  | 28.0000000000000000  |
| 42     | Duane   | 42.0000000000000000  |
| 228    | <null>  | 228.0000000000000000 |
| <null> | homer   | <null>               |
| <null> | mario   | <null>               |
| <null> | luigi   | <null>               |
+--------+---------+----------------------+
*/

----------------------------------------------------
-- Null in Unique Constraints
----------------------------------------------------

-- Unique constraints treat NULL as different to everything (including NULL)
-- That makes every NULL a different NULL so unique constratins accept multiple NULL VALUES

ALTER TABLE null_fun
ADD CONSTRAINT uniq_age UNIQUE (age);
-- ALTER TABLE
DESCRIBE null_fun;
/*
+----------+------------------------+-------------+
| Column   | Type                   | Modifiers   |
|----------+------------------------+-------------|
| id       | integer                |  not null   |
| fname    | character varying(255) |             |
| lname    | character varying(255) |             |
| age      | integer                |             |
+----------+------------------------+-------------+
Indexes:
    "null_fun_pkey" PRIMARY KEY, btree (id)
    "uniq_age" UNIQUE CONSTRAINT, btree (age)
*/
SELECT * FROM null_fun;
/*
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 1    | carlos  | torres  | 28     |
| 2    | Duane   | Lo Mein | 42     |
| 3    | homer   | <null>  | <null> |
| 4    | <null>  | <null>  | 228    |
| 5    | mario   | mario   | <null> |
| 6    | luigi   | mario   | <null> |
+------+---------+---------+--------+
*/
INSERT INTO null_fun VALUES 
  (DEFAULT, 'new', 'guy', NULL);
-- INSERT 0 1
INSERT INTO null_fun VALUES 
  (DEFAULT, 'young', 'ster', 28);
/*
duplicate key value violates unique constraint "uniq_age"
DETAIL:  Key (age)=(28) already exists.
*/
SELECT * FROM null_fun;
/*
+------+---------+---------+--------+
| id   | fname   | lname   | age    |
|------+---------+---------+--------|
| 1    | carlos  | torres  | 28     |
| 2    | Duane   | Lo Mein | 42     |
| 3    | homer   | <null>  | <null> |
| 4    | <null>  | <null>  | 228    |
| 5    | mario   | mario   | <null> |
| 6    | luigi   | mario   | <null> |
| 9    | new     | guy     | <null> |
+------+---------+---------+--------+
*/

-- Clean up
DELETE FROM null_fun WHERE id = 9;
-- DELETE 1
ALTER TABLE null_fun DROP CONSTRAINT uniq_age;
-- ALTER TABLE


----------------------------------------------------
-- Null in Order By
----------------------------------------------------

-- SQL standard leaves sorting of NULL values against NOT NULL values up to vendors
-- NULL may sort before or after NOT NULL values
-- SQL:2003 introduce ORDER BY modifier NULL (FIRST|LAST) so devs can control
-- Still not widely supported (just Postgres, Oracle, and DB2)

SELECT age
FROM null_fun
ORDER BY age ASC;
/*
+--------+
| age    |
|--------|
| 28     |
| 42     |
| 228    |
| <null> |
| <null> |
| <null> |
+--------+
*/

SELECT age
FROM null_fun
ORDER BY age DESC;
/*
+--------+
| age    |
|--------|
| <null> |
| <null> |
| <null> |
| 228    |
| 42     |
| 28     |
+--------+
*/

SELECT age
FROM null_fun
ORDER BY age ASC NULLS FIRST;
/*
+--------+
| age    |
|--------|
| <null> |
| <null> |
| <null> |
| 28     |
| 42     |
| 228    |
+--------+
*/

SELECT age
FROM null_fun
ORDER BY AGE DESC NULLS LAST;
/*
+--------+
| age    |
|--------|
| 228    |
| 42     |
| 28     |
| <null> |
| <null> |
| <null> |
+--------+
*/

-- Can use a CASE statment in ORDER BY to get around in other DBs
SELECT age
FROM null_fun
-- equivalent to ORDER BY AGE NULLS FIRST
ORDER BY CASE WHEN age is NULL
              THEN 0
	      ELSE 1
         END,
         age
;
/*
+--------+
| age    |
|--------|
| <null> |
| <null> |
| <null> |
| 28     |
| 42     |
| 228    |
+--------+
*/


-- Teardown
DROP TABLE null_fun;
